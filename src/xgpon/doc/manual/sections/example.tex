\section{XG-PON Simulation Example}
This appendix presents one example for XG-PON simulation with aim
to demonstrate the usage of XgponHelper. In this example,
dumb-bell topology is adopted and bi-directional UDP traffics are
generated between computers in core network (Left Servers and Left
Clients) and computers that access the Internet through XG-PON.
The code related with XG-PON simulation has been explained by
comments started with "////". The most important steps are to
install XgponNetDevice on the OLT and ONUs, configure IP addresses
for these nodes, and add XGEM Port (and the T-CONT related with
upstream XGEM Port) for carrying traffics of ONUs.


\lstset{language=C++, basicstyle=\scriptsize} %\lstset{language=C++, basicstyle=\tiny}
\begin{lstlisting}

/**************************************************************
* This script will create UDP client and server at both sides  to generate two-way traffics.
*
*                                                                            P2P
*                                                             ------- ONU1 ---------- UDP sink/sender 1
*                       P2P              P2P (CN)            /
*   Left Servers -------------- Gateway ------------ OLT-----
*                                |                           \               P2P
*                        P2P     |                            ------ ONUn ---------- UDP sink/sender n
*   Left Clients -----------------
**************************************************************/

#include <iostream>
#include <fstream>

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/object-factory.h"
#include "ns3/applications-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/stats-module.h"

////this header file must be included for simulating XG-PON.
#include "ns3/xgpon-module.h"

using namespace ns3;

////Some constants used in the simulation: 100 seconds to be simulated; 2 ONUs;
////10Mbps per ONU for downstream and 2.5Mbps for upstream.
#define APP_START_TIME   0
#define APP_STOP_TIME   100
#define SIM_STOP_TIME   (APP_STOP_TIME + 1)
#define ONU_NUM          2
#define UDP_PKT_SIZE     1500
#define DS_PKT_INTERVAL  0.001
#define US_PKT_INTERVAL  0.004

////for supporting NS-3 Log
NS_LOG_COMPONENT_DEFINE ("XgponSimulationSpeedFanUdp");

////trace sink used to print per-device statistics periodically (per second).
void DeviceStatisticsTrace (const XgponNetDeviceStatistics& stat)
{
  static uint64_t time2print = 1000000000;    //1,000,000,000 nanoseconds per second.
  if(stat.m_currentTime > time2print)
  {
    std::cout << (stat.m_currentTime / 1000000000L) << "seconds_have_been_simulated.";
    std::cout << "DS-BYTES:" << stat.m_passToXgponBytes;
    std::cout << ";US-BYTES:" << stat.m_rxFromXgponBytes;
    std::cout << ";FROM-CN-DS-BYTES:" << stat.m_rxFromUpperLayerBytes;
    std::cout << ";DROPPED-DS-BYTES:" << stat.m_overallQueueDropBytes;
    std::cout << std::endl;
    time2print += 1000000000;
  }
}

int main (int argc, char *argv[])
{
  ////default values for command-line options
  bool p_verbose = false;
  uint16_t p_nOnus = ONU_NUM;
  uint16_t p_appStartTime = APP_START_TIME;
  uint16_t p_appStopTime = APP_STOP_TIME;
  uint16_t p_simStopTime = SIM_STOP_TIME;
  uint16_t p_pktSize = UDP_PKT_SIZE;
  double p_dsPktInterval = DS_PKT_INTERVAL;
  double p_usPktInterval = US_PKT_INTERVAL;

  ////get command-line options
  CommandLine cmd;
  cmd.AddValue ("verbose", "Tell_application_to_log_if_true", p_verbose);
  cmd.AddValue ("onus", "the_number_of_onus", p_nOnus);
  cmd.AddValue ("astarttime", "the_start_time_of_applications", p_appStartTime);
  cmd.AddValue ("astoptime", "the_stop_time_of_applications", p_appStopTime);
  cmd.AddValue ("sstoptime", "the_stop_time_of_whole_simulation", p_simStopTime);
  cmd.AddValue ("dspktinterval", "the_packet_interval_of_downstream_udp_client(second)", p_dsPktInterval);
  cmd.AddValue ("uspktinterval", "the_packet_interval_of_upstream_udp_client(second)", p_usPktInterval);
  cmd.AddValue ("pktsize", "the_UDP_packet_size(byte)", p_pktSize);
  cmd.Parse (argc,argv);

  if(p_verbose)
  {
    LogComponentEnable ("UdpClient", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpServer", LOG_LEVEL_INFO);
    LogComponentEnable ("XgponChannel", LOG_LEVEL_FUNCTION);
  }
  Packet::EnablePrinting ();

  ////////Create all nodes and organize them into the corresponding containers for installing network devices.
  ////the ONUs, OLT nodes, and container for all xgpon nodes
  NodeContainer oltNode, onuNodes, xgponNodes;
  oltNode.Create (1);
  onuNodes.Create (p_nOnus);
  xgponNodes.Add(oltNode.Get(0));
  for(int i=0; i<p_nOnus; i++) { xgponNodes.Add (onuNodes.Get(i)); }

  //the gateway node, OLT node, and container for the link to simulate Internet's core network
  NodeContainer gatewayNode, cnNodes;
  gatewayNode.Create (1);
  cnNodes.Add(oltNode.Get(0));
  cnNodes.Add(gatewayNode.Get(0));

  //the end hosts at both sides of the networks
  NodeContainer leftServerNode, leftClientNode, rightNodes;
  NodeContainer leftServerLinkNodes, leftClientLinkNodes;
  NodeContainer rightLinkNodes[p_nOnus];
  leftServerNode.Create (1);
  leftClientNode.Create (1);
  leftServerLinkNodes.Add(leftServerNode.Get(0));
  leftServerLinkNodes.Add(gatewayNode.Get(0));
  leftClientLinkNodes.Add(leftClientNode.Get(0));
  leftClientLinkNodes.Add(gatewayNode.Get(0));

  rightNodes.Create (p_nOnus);
  for(int i=0; i<p_nOnus; i++)
  {
    rightLinkNodes[i].Add(rightNodes.Get(i));
    rightLinkNodes[i].Add(onuNodes.Get(i));
  }

  ////////Create all links used to connect the above nodes
  ////Xgpon network configuration through XgponHelper
  XgponHelper xgponHelper;
  XgponConfigDb& xgponConfigDb = xgponHelper.GetConfigDb ( );

  xgponConfigDb.SetOltNetmaskLen (16);
  xgponConfigDb.SetOnuNetmaskLen (24);
  xgponConfigDb.SetIpAddressFirstByteForXgpon (10);
  xgponConfigDb.SetIpAddressFirstByteForOnus (172);

  ////other configuration related information
  Config::SetDefault("ns3::XgponOltDbaEngineRoundRobin::MaxServiceSize", UintegerValue(1000));  //1000 words
  Config::SetDefault("ns3::XgponOltDsSchedulerRoundRobin::MaxServiceSize", UintegerValue(10000));  //10K bytes
  Config::SetDefault("ns3::XgponOnuUsSchedulerRoundRobin::MaxServiceSize", UintegerValue(4000));  //4K bytes

  ////Set TypeId String for object factories through XgponConfigDb before the following call.
  ////initialize object factories
  xgponHelper.InitializeObjectFactories ( );

  ////configuration through object factory
  xgponHelper.SetQueueAttribute ("MaxBytes", UintegerValue(50000));  //queue size is 50KBytes

  ////install xgpon network devices
  NetDeviceContainer xgponDevices = xgponHelper.Install (xgponNodes);


  //Internet core network through PointToPointHelper
  PointToPointHelper p2pHelper;
  p2pHelper.SetDeviceAttribute ("DataRate", StringValue ("20000Mbps"));
  p2pHelper.SetChannelAttribute ("Delay", StringValue ("10ms"));
  p2pHelper.SetQueue ("ns3::DropTailQueue", "MaxPackets", UintegerValue (2000));
  NetDeviceContainer cnDevices = p2pHelper.Install (cnNodes);

  //links for connecting end hosts to routers/onus through PointToPointHelper
  p2pHelper.SetDeviceAttribute ("DataRate", StringValue ("20000Mbps"));
  p2pHelper.SetChannelAttribute ("Delay", StringValue ("2ms"));
  p2pHelper.SetQueue ("ns3::DropTailQueue", "MaxPackets", UintegerValue (2000));
  NetDeviceContainer leftServerLinkDevices, leftClientLinkDevices;
  leftServerLinkDevices = p2pHelper.Install (leftServerLinkNodes);
  leftClientLinkDevices = p2pHelper.Install (leftClientLinkNodes);

  p2pHelper.SetDeviceAttribute ("DataRate", StringValue ("20000Mbps"));
  p2pHelper.SetChannelAttribute ("Delay", StringValue ("2ms"));
  p2pHelper.SetQueue ("ns3::DropTailQueue", "MaxPackets", UintegerValue (100));
  NetDeviceContainer rightLinkDevices[p_nOnus];
  for(int i=0; i<p_nOnus; i++)
  {
    rightLinkDevices[i] = p2pHelper.Install (rightLinkNodes[i]);
  }

  ////////install internet protocol stack
  InternetStackHelper stack;
  stack.Install (xgponNodes);
  stack.Install (leftServerNode);
  stack.Install (leftClientNode);
  stack.Install (rightNodes);
  stack.Install (gatewayNode);

  ////////Assign IP addresses to all interfaces of all nodes
  Ipv4AddressHelper addressHelper;

  //Assign IP addresses to core network nodes (point-to-point link)
  std::string cnIpbase = xgponHelper.GetIpAddressBase (150, 0, 24);
  std::string cnNetmask = xgponHelper.GetIpAddressNetmask (24);
  addressHelper.SetBase (cnIpbase.c_str(), cnNetmask.c_str());
  Ipv4InterfaceContainer cnInterfaces = addressHelper.Assign (cnDevices);
  if(p_verbose)
  {
    Ipv4Address tmpAddr = cnInterfaces.GetAddress(0);
    std::cout << "OLT_Internet_Interface'sIP_Address:";
    tmpAddr.Print(std::cout);
    std::cout << std::endl;
    tmpAddr = cnInterfaces.GetAddress(1);
    std::cout << "Internet_Gateway's_IP_Address:";
    tmpAddr.Print(std::cout);
    std::cout << std::endl;
  }

  //Assign IP addresses to end hosts at the left side (point-to-point link)
  Ipv4InterfaceContainer leftServerLinkInterfaces, leftClientLinkInterfaces;
  std::string leftServerIpbase = xgponHelper.GetIpAddressBase (160, 1, 24);
  std::string leftServerNetmask = xgponHelper.GetIpAddressNetmask (24);
  addressHelper.SetBase (leftServerIpbase.c_str(), leftServerNetmask.c_str());
  leftServerLinkInterfaces = addressHelper.Assign (leftServerLinkDevices);
  std::string leftClientIpbase = xgponHelper.GetIpAddressBase (160, 2, 24);
  std::string leftClientNetmask = xgponHelper.GetIpAddressNetmask (24);
  addressHelper.SetBase (leftClientIpbase.c_str(), leftClientNetmask.c_str());
  leftClientLinkInterfaces = addressHelper.Assign (leftClientLinkDevices);

  ////Assign IP addresses to OLT and ONU (for xgpon network devices)
  Ptr<XgponOltNetDevice> tmpDevice = DynamicCast<XgponOltNetDevice, NetDevice> (xgponDevices.Get(0));
  std::string xgponIpbase = xgponHelper.GetXgponIpAddressBase ( );
  std::string xgponNetmask = xgponHelper.GetOltAddressNetmask();
  addressHelper.SetBase (xgponIpbase.c_str(), xgponNetmask.c_str());
  Ipv4InterfaceContainer xgponInterfaces = addressHelper.Assign (xgponDevices);
  for(int i=0; i<(p_nOnus+1);i++)
  {
    Ipv4Address addr = xgponInterfaces.GetAddress(i);
    Ptr<XgponNetDevice> tmpDevice = DynamicCast<XgponNetDevice, NetDevice> (xgponDevices.Get(i));
    tmpDevice->SetAddress (addr);
    if(p_verbose)
    {
      if(i==0) std::cout << "OLT_IP_Address:";
      else std::cout << "ONU" << (i-1) <<"IP_Address:";
      addr.Print(std::cout);
      std::cout << std::endl;
    }
  }

  //Assign IP addresses to end hosts at the right side (point-to-point link)
  Ipv4InterfaceContainer rightLinkInterfaces[p_nOnus];
  for(int i=0; i<p_nOnus; i++)
  {
    Ptr<XgponOnuNetDevice> tmpDevice = DynamicCast<XgponOnuNetDevice, NetDevice> (xgponDevices.Get(i+1));
    std::string onuIpbase = xgponHelper.GetOnuIpAddressBase (tmpDevice);
    std::string onuNetmask = xgponHelper.GetOnuAddressNetmask();
    addressHelper.SetBase (onuIpbase.c_str(), onuNetmask.c_str());
    rightLinkInterfaces[i] = addressHelper.Assign (rightLinkDevices[i]);
    if(p_verbose)
    {
      Ipv4Address addr = rightLinkInterfaces[i].GetAddress(0);
      std::cout << "Right_Node " << i <<"IP_Address:";
      addr.Print(std::cout);
      std::cout << std::endl;
      addr = rightLinkInterfaces[i].GetAddress(1);
      std::cout << "IP_Address_at_the_Corresponding_ONU:";
      addr.Print(std::cout);
      std::cout << std::endl;
    }
  }

  ////Add OMCI Channels
  //set attributes (QoS parameters, etc.) for connections to be added as OMCI channel
  //we need get the address before setting OMCI channel.
  //for(int i=0; i<p_nOnus; i++)
  //{
  //  Ptr<XgponOltNetDevice> oltDevice = DynamicCast<XgponOltNetDevice, NetDevice> (xgponDevices.Get(0));
  //  Ptr<XgponOnuNetDevice> onuDevice = DynamicCast<XgponOnuNetDevice, NetDevice> (xgponDevices.Get(i+1));
  //  xgponHelper.AddOmciConnectionsForOnu (onuDevice, oltDevice);
  //}

  ////add xgem ports for end hosts connected to ONUs
  for(int i=0; i<p_nOnus; i++)
  {
    Address addr = rightLinkInterfaces[i].GetAddress(0);
    Ptr<XgponOltNetDevice> oltDevice = DynamicCast<XgponOltNetDevice, NetDevice> (xgponDevices.Get(0));
    Ptr<XgponOnuNetDevice> onuDevice = DynamicCast<XgponOnuNetDevice, NetDevice> (xgponDevices.Get(i+1));
    uint16_t allocId = xgponHelper.AddOneTcontForOnu (onuDevice, oltDevice);
    uint16_t upPortId = xgponHelper.AddOneUpstreamConnectionForOnu (onuDevice, oltDevice, allocId, addr);
    uint16_t downPortId = xgponHelper.AddOneDownstreamConnectionForOnu (onuDevice, oltDevice, addr);
    if(p_verbose)
    {
      std::cout << "ONU-ID="<<onuDevice->GetOnuId() << ";ALLOC-ID=" << allocId
                << ";UP-PORT-ID=" << upPortId << ";DOWN-PORT-ID=" << downPortId << std::endl;
    }
  }

  /////////Populate routing tables for all nodes
  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

  //////////generating traffics
  //Containers (downstream)
  ApplicationContainer leftServers, rightServers;
  uint16_t leftServerPort=9000;
  uint16_t rightServerPort=9001;

  //Set UdpServer on left nodes
  UdpServerHelper leftServerHelper (leftServerPort);
  leftServers = leftServerHelper.Install (leftServerNode);
  leftServers.Start (Seconds (0));
  leftServers.Stop (Seconds (p_appStopTime));

  //Set UdpServer on right nodes
  UdpServerHelper rightServerHelper (rightServerPort);
  rightServers = rightServerHelper.Install (rightNodes);
  rightServers.Start (Seconds (0));
  rightServers.Stop (Seconds (p_appStopTime));

  //SetUdpClient on left nodes (generate downstream traffic); connect to right servers
  for(int i=0; i<p_nOnus; i++)
  {
    UdpClientHelper udpClientHelper (rightLinkInterfaces[i].GetAddress(0), rightServerPort);
    udpClientHelper.SetAttribute ("MaxPackets", UintegerValue (2000000000));
    udpClientHelper.SetAttribute ("Interval", TimeValue (Seconds (p_dsPktInterval)));
    udpClientHelper.SetAttribute ("PacketSize", UintegerValue (p_pktSize));
    ApplicationContainer clientApp = udpClientHelper.Install (leftClientNode.Get (0));
    clientApp.Start (Seconds (p_appStartTime + i * 0.001));
    clientApp.Stop (Seconds (p_appStopTime));
  }

  //SetUdpClient on right nodes (generate upstream traffic); connect to left servers
  for(int i=0; i<p_nOnus; i++)
  {
    UdpClientHelper udpClientHelper (leftServerLinkInterfaces.GetAddress(0), leftServerPort);
    udpClientHelper.SetAttribute ("MaxPackets", UintegerValue (2000000000));
    udpClientHelper.SetAttribute ("Interval", TimeValue (Seconds (p_usPktInterval)));
    udpClientHelper.SetAttribute ("PacketSize", UintegerValue (p_pktSize));
    ApplicationContainer clientApp = udpClientHelper.Install (rightNodes.Get (i));
    clientApp.Start (Seconds (p_appStartTime + i * 0.001));
    clientApp.Stop (Seconds (p_appStopTime));
  }

  ////ascii and pcap feature
  if(p_verbose)
  {
    xgponHelper.EnableAsciiAll("xgpon-simulation-speed-fan-udp-ascii");
    xgponHelper.EnablePcapAll("xgpon-simulation-speed-fan-udp-pcap");
  }

  ////print per-net-device statistics at the OLT
  Ptr<XgponOltNetDevice> oltDevice = DynamicCast<XgponOltNetDevice, NetDevice> (xgponDevices.Get(0));
  oltDevice->TraceConnectWithoutContext ("DeviceStatistics", MakeCallback(&DeviceStatisticsTrace));

  std::cout<<std::endl;
  Simulator::Stop(Seconds(p_simStopTime));
  Simulator::Run ();
  Simulator::Destroy ();
  std::cout<<std::endl;
  return 0;
}

\end{lstlisting}
